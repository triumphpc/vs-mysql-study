`explain extended select * from posts
join members m on posts.USERID = m.USERID
-> join inbox i on m.type = i.type
-> ;
+----+-------------+-------+------------+--------+---------------+---------+---------+------------------------+-------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                    | rows  | filtered | Extra                                              |
+----+-------------+-------+------------+--------+---------------+---------+---------+------------------------+-------+----------+----------------------------------------------------+
|  1 | SIMPLE      | posts | NULL       | ALL    | USERID_idx    | NULL    | NULL    | NULL                   | 25339 |   100.00 | NULL                                               |
|  1 | SIMPLE      | m     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | dev_kwork.posts.USERID |     1 |   100.00 | NULL                                               |
|  1 | SIMPLE      | i     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                   | 47806 |    10.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+--------+---------------+---------+---------+------------------------+-------+----------+----------------------------------------------------+
3 rows in set, 2 warnings (0.02 sec)`

|Поле|Описание|
| --- | --- |
|id|порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)|
|select_type|тип запроса SELECT.|
| |SIMPLE — Простой запрос SELECT без подзапросов или UNION’ов|
| |PRIMARY – данный SELECT – самый внешний запрос в JOIN’е|
| |DERIVED – данный SELECT является частью подзапроса внутри FROM|
| | SUBQUERY – первый SELECT в подзапросе|
| |DEPENDENT SUBQUERY – подзапрос, который зависит от внешнего запроса|
| | UNCACHABLE SUBQUERY – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)|
| |UNION – второй или последующий SELECT в UNION’е|
| |DEPENDENT UNION – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса
| |UNION RESULT – результат UNION’а|
|Table| таблица, к которой относится выводимая строка|
|Type| — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан. В следующем списке описаны типы соединений, отсортированные от лучшего к худшему :|
| |System – таблица имеет только одну строку|
| |Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.|
| |Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.|
| |Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = > Все строки с совпадающими значениями индекса считываются из этой таблицы для каждой комбинации строк из предыдущих таблиц. ref используется, если в соединении используется только крайний левый префикс ключа или если ключ не является индексом PRIMARY KEYили UNIQUE(другими словами, если объединение не может выбрать одну строку на основе значения ключа). Если используемый ключ соответствует только нескольким строкам, это хороший тип соединения.|
| | Fulltext – соединение использует полнотекстовый индекс таблицы|
| |Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца|
| |Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.|
| |Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.|
| |Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.|
| |Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.|Извлекаются только строки, которые находятся в заданном диапазоне, с использованием индекса для выбора строк. Ключевой столбец в выходной строке указывает, какой индекс используется. Key_len содержит самую длинную ключевую часть, которая использовалась. Столбец ref предназначен NULLдля этого типа.Диапазон можно использовать, когда ключевой столбец сравнивается с константой с помощью любого из =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() операторов (см. подробнее MRR)
| |Index – сканируется все дерево индексов для нахождения соответствующих строк.|
|All|  – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.|
| |Возможные значения:|
| Possible_keys| – показывает индексы, которые могут быть использованы для нахождения строк в таблице . Об этом говорит сайт https://intellect.icu . На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .||
| Key |– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.|
|Key_len| – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков. На эту тему вот cсылка|
|Ref| – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.|
|Rows| – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.|
|Extra| – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь|


Источник: https://intellect.icu/ispolzovanie-i-analiz-indeksov-v-mysql-v-where-i-v-join-zaprosakh-explain-i-optimizatsiya-zaprosov-red-metod-dlya-analiza-proizvoditelnosti-7894